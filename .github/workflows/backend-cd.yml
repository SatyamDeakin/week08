name: CD - Deploy Backend Services to AKS

on:
  workflow_dispatch:
    inputs:
      aks_cluster_name:
        description: 'AKS cluster name'
        required: true
        default: 'aks-demo'
      aks_resource_group:
        description: 'AKS resource group'
        required: true
        default: 'rg-aks-demo'
      namespace:
        description: 'Kubernetes namespace (dev or prod)'
        required: true
        default: 'dev'
      product_service_name:
        description: 'K8s Service name for product API'
        required: true
        default: 'product-service'
      order_service_name:
        description: 'K8s Service name for order API'
        required: true
        default: 'order-service'
      # Optional: set images explicitly if you want to pin to this commit/tag
      set_images:
        description: 'Set Deployment images to ACR images for this commit? (true/false)'
        required: true
        default: 'true'

env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }} # e.g. mystudentregistry.azurecr.io

jobs:
  deploy_backend:
    runs-on: ubuntu-latest
    environment: Production

    outputs:
      PRODUCT_API_URL: ${{ steps.make_outputs.outputs.product_url }}
      ORDER_API_URL:   ${{ steps.make_outputs.outputs.order_url }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Azure login (client secret)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ inputs.aks_resource_group }}
          cluster-name:   ${{ inputs.aks_cluster_name }}

      - name: Ensure namespace exists
        run: |
          kubectl get ns "${{ inputs.namespace }}" || kubectl create ns "${{ inputs.namespace }}"

      - name: Apply backend infrastructure (ConfigMaps/Secrets/DBs)
        run: |
          kubectl -n "${{ inputs.namespace }}" apply -f k8s/configmaps.yaml
          kubectl -n "${{ inputs.namespace }}" apply -f k8s/secrets.yaml
          kubectl -n "${{ inputs.namespace }}" apply -f k8s/product-db.yaml
          kubectl -n "${{ inputs.namespace }}" apply -f k8s/order-db.yaml

      - name: Apply backend services (Deployments/Services)
        run: |
          kubectl -n "${{ inputs.namespace }}" apply -f k8s/product-service.yaml
          kubectl -n "${{ inputs.namespace }}" apply -f k8s/order-service.yaml

      # OPTIONAL: set images (assumes your CI pushed :${{ github.sha }} tags)
      - name: Set images to this commit (if requested)
        if: ${{ inputs.set_images == 'true' }}
        shell: bash
        run: |
          # Detect container names for each Deployment (first container)
          PROD_DEP=$(kubectl -n "${{ inputs.namespace }}" get deploy -o name | grep -E 'product|prod' | head -n1 | cut -d/ -f2 || echo "")
          ORDER_DEP=$(kubectl -n "${{ inputs.namespace }}" get deploy -o name | grep -E 'order'        | head -n1 | cut -d/ -f2 || echo "")

          if [ -z "$PROD_DEP" ] || [ -z "$ORDER_DEP" ]; then
            echo "Could not auto-detect deployment names. Falling back to product-service/order-service."
            PROD_DEP="product-service"
            ORDER_DEP="order-service"
          fi

          PROD_CONT=$(kubectl -n "${{ inputs.namespace }}" get deploy "$PROD_DEP" -o jsonpath='{.spec.template.spec.containers[0].name}')
          ORDER_CONT=$(kubectl -n "${{ inputs.namespace }}" get deploy "$ORDER_DEP" -o jsonpath='{.spec.template.spec.containers[0].name}')

          IMG_PROD="${{ env.ACR_LOGIN_SERVER }}/product_service:${{ github.sha }}"
          IMG_ORDER="${{ env.ACR_LOGIN_SERVER }}/order_service:${{ github.sha }}"

          echo "Setting $PROD_DEP/$PROD_CONT -> $IMG_PROD"
          echo "Setting $ORDER_DEP/$ORDER_CONT -> $IMG_ORDER"

          kubectl -n "${{ inputs.namespace }}" set image deploy/$PROD_DEP  $PROD_CONT="$IMG_PROD"
          kubectl -n "${{ inputs.namespace }}" set image deploy/$ORDER_DEP $ORDER_CONT="$IMG_ORDER"

          kubectl -n "${{ inputs.namespace }}" rollout status deploy/$PROD_DEP  --timeout=300s
          kubectl -n "${{ inputs.namespace }}" rollout status deploy/$ORDER_DEP --timeout=300s

      - name: Ensure Services are type LoadBalancer
        shell: bash
        run: |
          kubectl -n "${{ inputs.namespace }}" patch svc "${{ inputs.product_service_name }}" -p '{"spec":{"type":"LoadBalancer"}}' --type=merge || true
          kubectl -n "${{ inputs.namespace }}" patch svc "${{ inputs.order_service_name }}"   -p '{"spec":{"type":"LoadBalancer"}}' --type=merge || true

      - name: Wait for LoadBalancer IPs/hostnames (up to 5 min)
        id: wait_ips
        shell: bash
        run: |
          NS="${{ inputs.namespace }}"
          PSVC="${{ inputs.product_service_name }}"
          OSVC="${{ inputs.order_service_name }}"

          for i in $(seq 1 60); do
            echo "Attempt $i/60..."
            P_IP=$(kubectl -n "$NS" get svc "$PSVC" -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            O_IP=$(kubectl -n "$NS" get svc "$OSVC" -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            P_HOST=$(kubectl -n "$NS" get svc "$PSVC" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            O_HOST=$(kubectl -n "$NS" get svc "$OSVC" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

            # prefer IP; fall back to hostname (some clouds fill hostname only)
            [ -z "$P_IP" ] && P_IP="$P_HOST"
            [ -z "$O_IP" ] && O_IP="$O_HOST"

            if [[ -n "$P_IP" && -n "$O_IP" ]]; then
              echo "Product: $P_IP"
              echo "Order:   $O_IP"
              echo "P_ADDR=$P_IP" >> $GITHUB_ENV
              echo "O_ADDR=$O_IP" >> $GITHUB_ENV
              exit 0
            fi
            sleep 5
          done

          echo "LoadBalancer addresses not ready after timeout."
          kubectl -n "$NS" get svc
          exit 1

      - name: Build service URLs & expose as outputs
        id: make_outputs
        shell: bash
        run: |
          # Change ports here if your Services expose different ones
          P_URL="http://${P_ADDR}:8000"
          O_URL="http://${O_ADDR}:8001"
          echo "product_url=$P_URL" >> $GITHUB_OUTPUT
          echo "order_url=$O_URL"   >> $GITHUB_OUTPUT
          echo "Product API URL: $P_URL"
          echo "Order   API URL: $O_URL"

      - name: Azure logout
        if: always()
        run: az logout
